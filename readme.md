## <center>tinyShell模拟命令行  程序说明文档</center>

> All grown-ups started out as children, but few of them remember it.      --*The Little Prince*

### 1  项目简介

#### 程序概要

本项目是《程序设计基础》课程大作业——模拟命令行的程序实现。

除解释器框架外，本项目还实现了包括diff、grep、cat、cd、echo、cp等在内的命令行常用指令及其在说明文档中提及的所有配套功能。指令的输出模式参照说明文档样例与Ubuntu 20.04。

#### 分工情况

| 成员信息                        | 分工内容                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| 材02 陈方弈 2020011392 （组长） | Part 1: diff指令实现与调试<br />项目汇总与整合、模块1,3,4代码封装、说明文档编写、git maintainer |
| 计13 金洪民 2021010742          | Part 2: grep指令实现、调试与代码封装、整合后代码测试         |
| 软件13 穆俊成 2021011820        | Part 3: tee/cat/cp/cd/pwd指令实现与调试、整合后代码测试      |
| 经12-计18 陈翔宇 2021011050     | Part 4: 解释器框架与echo指令实现与调试<br />整合后代码测试、协调各部分工作、演示视频制作与剪辑、~~场地提供~~ |

#### 开发信息

OS: Windows 10/Windows 11; Windows Subsystem for Linux (Ubuntu 20.04)

IDE: Microsoft Visual Studio 2019 Community

Gitlab(Tsinghua) Repo:[[陈方弈 / tinyShell · GitLab (tsinghua.edu.cn)](https://git.tsinghua.edu.cn/chenfang20/tinyshell)](https://github.com/SekiroYoumu/tinyShell_Diff) ~第一次用git进行多人开发，用得稀烂~

### 2  代码架构

除5个测试文件以外，整个工程的源文件由5个头文件与13个源代码文件组成，整体如下图所示。

代码以模块化形式封装：

- 除constant.h是项目四个部分共用的（包括公用的声明与#include等）以外，指令实现的三个部分彼此独立并使用独立的头文件，以增强代码可读性；
- 四个部分仅仅共用gTerm一个全局变量（constant.h中声明，main.cpp中定义），以保证封装可靠；其他信息传递均采用传参方式进行；
- 除gTerm外其他全局变量使用的范围仅限于各自部分内，目的是避免栈空间溢出或方便子函数之间的数据传递。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109205551324.png" alt="image-20220109205551324" style="zoom:67%;" />

### 3 功能实现情况与相关说明

#### 3.1 diff指令

##### 实现框架图

<div align=center><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211209085910910.png" alt="image-20211209085910910" style="zoom:155%;" /></div>

图例见右下角。

##### 实现功能

函数功能是接受参数后从文件（或从tinyShell项目的标准输入`gTerm.strin`）中读取字符串，逐行进行比较后将结果输出至tinyShell项目的标准输出`gTerm.strout`。所有作业说明中提到的功能均完全实现。

通过采用**Myers' diff算法**实现不同行最短路径（i.e.:最少编辑次数）的匹配；其余如输入输出格式、报错样式、开关功能均与Linux（Ubuntu 20.04）相同。

##### 实现说明

###### 	3.1.1 Myers算法：doDiff主体部分

Myers算法的核心在于以动态规划的方式找出SES，且这样的最短路径具有**“先删除后新增”**的良好性质（该性质使得输出更加直观，特别是在比较两个文件的差异时相当有用）。

判断“删”或“增”并将结果以结构体`struct LineRelation`形式封装（包含出现不同的两行以及行间关系（删或增））后压入栈`stack<LineRelation> line`。



<div align=center><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211209211645246.png" alt="image-20211209211645246" style="zoom:50%;" /><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211209211717181.png" alt="image-20211209211717181" style="zoom:40%;" /></div>

*参考图出自Myers Paper原文*：Myers, E.W., 1986. AnO(ND) difference algorithm and its variations. *Algorithmica*, 1(1-4), pp.251–266.

###### 	3.1.2 结果输出

由3.1.1得到的结果是未经处理的：Linux diff显示应有三种模式（删除d、添加a、修改c），而上述算法得到的结果并未包含“修改”。

因此，在将结果按要求输出之前，`printResult`函数会逐个从栈顶取出区别行进行分析；在先出现“删除d”后连续出现“新增a”（Myers算法的特性决定不可能先新增后删除）的情况下，将这一部分更改为“修改c”；

###### 3.1.3 输出参数（开关）解析

大作业题目所要求的Linux diff开关（"--help"除外，单独考虑）主要可以分为两类：

- "-w", "-i", "-b"，对文件逐行比对的规则产生作用——对应在“比对行”（`customStrcmp`）处做修改，此略；

- "-I [string]", "-B", "-q"，对输出形式产生作用——对应在“结果输出”（`printResult`）处做修改。

  - -B要求除去空行后行数不变，因此无法在doDiff函数主体部分做更改；本程序选择在`printResult`筛去“区别行”中样本A或样本B为空行的情况。

  - -q只决定输出形式而不决定比较方式，可能与其他开关耦合，因此需等全部关系都判断完后再做“有无区别”的输出。本程序用`printResult`返回的布尔值判断是否有区别。

  - -I的特殊情况是：在未达到“这几行同时都包含了选项中指定字符串”的要求时应按原样输出，因此置于`printResult `中逐个对“区别行”作有无特定字符串的判断。


注：上述两类开关可能同时出现，并没有明显地互相排斥的情况，经验证可以互相耦合。

###### 3.1.4 复杂度分析

在doDiff函数中，复杂度的主要来源是寻找SES的过程。Myers的论文原文中已有详尽的复杂度分析：设N为样本A与样本B的行数之和，则时间复杂度为O(ND)（D为SES的长度），空间复杂度为O(N^2)。

在最坏的情况下（两个样本的所有行均失配）下时间复杂度为O(N^2) ，但在一般情况下这样的情况较少出现，所以算法的时间复杂度在大部分情况下会是O(ND)的。由于需要开辟二维数组以存放路径，算法（本部分采用其基础形式，未做空间优化）的空间复杂度较高，但在实测中仍然可以处理10^4行以内的文本比对。

#### 3.2 grep指令

##### 实现框架图![image-20220109210809455](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109210809455.png)

##### 实现功能

grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，

基本上实现了说明文档的要求，其中包括：

- grep函数的基本功能：查找并将符合字段变为亮红色加粗，并将所在行输出
- grep函数的多选项功能:基本上实现了函数的多种可选选项
- grep函数中模式串中通配符的要求基本实现
- grep函数对于多文件一同输出的要求基本实现

##### 实现说明

预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。

###### 3.2.1 将“得到的字符串”与模板模式串比较并将符合条件的字符串的部分变为亮红色

所需函数为`<string>`中的find 函数。

###### 3.2.2 转换指令字符串集为实际功能

--help 帮助指令 ；-c 在匹配时加上counter；-h/H、-n、-/:每一行的输出内容；<文件名> 编号 -/: 查找后的字符串

注意：文件名的颜色为加粗紫色，行号的颜色为加粗亮绿色，-和：为加粗亮蓝色

###### 3.2.3：通配符处理：.或*

- 我们在查找中得到需要处理的首地址与尾地址（注：查找地址当取第一个首地址（find函数）与最后一个末地址（rfind函数）） 

  ACB   首地址、字符串长度

  A.B   “前后”的地址差为2，若成立则取前地址为首地址，与配对的后地址为末地址

  A*B   存在的地址存在前后的配对关系

- 在上述情况下，把模式串通配符前与后的字符串分开，（按不止一个考虑）按通配符数+1开数组从第一个通配符开始查找，将新查找得到的字符串的首项，再对下一个通配符查找，直到遇到\0，返回新字符串首地址与尾地址。

  .B  B. 前一或后一

  \*A  A* 开头/结尾

  -与/ 用一个bool值

- 此时的输出行数：用bool数组，若拓展行已有查找，则不再输出；

- 此时的标红输出：注意新字符串对应地址位置与原地址不同，需要转换；行首地址到标记字符串正常输出，标记字符串首地址到尾地址亮红色输出，标记字符串尾地址到行尾地址，正常输出。

#### 3.3 模块三(tee/cat/cp/cd/pwd)

模块三共5条指令，tee/cat/cp/cd/pwd，数量较多但单个的难度相对较低，对于算法的要求比较低；函数彼此不存在相互调用的情况，并且依据文档直接从标准输入或文件中读取内容。

##### 相比单人部分时的改动

- 个人部分手动对文件名后面连接了“.txt”，在小组合作时删除了相应的多余代码（要求用户输入的文件名是含有文件后缀）；
- 对于cd指令，说明文档中提到“不可切换到根目录以上目录，用户自行保证输入的目录存在”；在测试过程中，当工作目录已经是“/”即预设的根目录时，输入指令“cd ..”就会出现问题。因此参考真实命令行进行调整，在返回根目录以上目录时，会将工作路径留存在“/”根目录。

##### 整体框架图

![image-20220109210833229](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109210833229.png)

##### 实现功能

1、tee指令已完成全部内容，包括追加写入和覆盖写入，依据用户是否输入了“-a”；

2、cat指令的实现难度比其余函数高，因为存在着多种情况，本人代码特点是任何“-n”、“-E”等等可以以任何顺序，任意个数（在不产生歧义情况下）组合出现，“-n”与“-b”不可同时出现，“-s”与“-E”同时出现时，先删除多行连续空白行再进行行末连接$字符；

3、cd指令比起个人模块我做了调整优化，但是仍需用户自行保证输入的目录真实存在；

4、cp、pwd指令较简单，此略。

##### 实现说明

本部分共包含三个工具函数：

- 首先是把模拟的目录前正确的连接真实根目录以便能够正确的打开文件；
- 第二个是判断能否找到目标文件的函数，利用文件流，若打不开文件则会返回0，并且相应的函数会提示用户找不到文件；
- 第三个是将字符串倒置的函数，用于cat函数的书写。

1、tee指令的实现比较简单，利用文件流，并分类讨论追加写入和覆盖写入，可保存至多个文件。

2、Cat指令首先遍历argv去查找所有的“-n”等输入。在指令后便是文件，我利用了getline函数配合循环，将文件中的内容分行分别记录于字符串中。然后按照逻辑顺序，例如先判断有无“-s”若有则先对多行空白行进行合并，方法是判断某行字符串的长度是否为零；再去判断某“-n”、“-b”实现标号，我通过将每一行利用倒置函数倒置并且在末尾连接上序号再将字符串倒回来，实现了对齐标号。“-e”只需要在行末连接即可。

3、Cd指令我采用了模拟栈的形式，以“/”为分界将字符串划分为多个子块，去检索其中有无“/..”和“/.”如果有则会分别弹出两个栈元素，和一个栈元素。

4、cp、pwd指令较简单，此略。

#### 3.4 解释器：框架、复合指令、echo

##### 框架图

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109210914119.png" alt="image-20220109210914119" style="zoom:90%;" />

##### 实现功能

1、解释器框架读入用户输入的文本内容，将其拆分成命令行参数，并统计出参数的数量，即给出argv，argc，提供给其它模块调用。

2、echo指令可以看做是解释器框架的逆向实现。

echo指令和其它指令一样，也需要调用argv和argc。它将argv中的字符串重新组合，输出到标准输出中。单独使用时，可以将echo后面的内容单独输出到屏幕上；因为其可以将标准输入中的内容转化到标准输出中，因此也可以复合其它指令，如和tee指令进行复合，从而简单地写入文件。

3、复合指令会将两个指令复合成一个指令，前一个指令的输出将作为下一个指令的输入。

具体地，将先执行前一个指令，执行后并不将标准输出中的内容输出到屏幕上，而是将标准输出中的内容覆盖到标准输入上，再次拆分出命令行参数，统计出参数数量，执行下一条指令。

##### 实现说明及相关改动

###### 3.4.1 指令传递与复合指令

个人提交时上传的代码其实有很大的问题，这个问题在小组作业汇总时也体现了出来。个人部分时使用了二维数组来实现argv，因此其它模块的函数调用argv时出现了类型的不兼容。针对该问题并未重构源代码，而是用二维指针配合new重写了一遍。

由于代码不方便重构，采用两套argv和argc，包括arg(c,v)0和arg(c,v)。argv0和argc0会考虑到用户输入的所有内容，argv和argc只会考虑到第一个复合指令之前的内容。这主要是为了方便复合指令的实现。

###### 3.4.2 解释器框架

1、read子函数

读取命令及命令行参数由read函数实现。具体地，用户通过键盘输入的内容将会被收集到缓冲区中，read将扫描缓冲区，将字符复制到argv0中，当遇到空格时，argc0会加1，将后面的字符输入的下一个argv0中。

2、analyze子函数

之后是analyze函数。analyze是整个解释器框架的关键部分。函数会找到第一个复合指令的位置，把它前面的内容复制到argv中，同时将其下标作为argc。接着，会考虑用户输入的第一个字符串，将其与指令库中的指令进行比对，如果没有找到这个指令，就会直接在屏幕上输出错误提示，若找到了相应指令，就会执行。

复合指令天生适合用递归实现。如果存在复合指令，函数的最后会递归调用它本身，不过在这之前，它会处理argv0和argc0，具体地，将第一个复合指令之后的argv0覆盖到前面，更新argc0，将标准输出中的内容覆盖到标准输入上，清空标准输出，再递归调用自身，从而再产生新的argv，argc，供下一个指令调用。



由一个do-while循环来实现main函数中的主体部分，包括清空标准输入、标准输出、argv，重置argc，进行指令的读取和分析，以及输出标准输出中的内容。

输出标准输出中的内容时，会判断末尾是否有换行符，如果没有会添加换行符，如果已经有了换行符则会直接输出。

由于analyze函数的递归调用，复合指令中的前一个指令产生的标准输出并不会被输出到屏幕上，而是在所有指令执行之后才输出。输出标准输出到屏幕后，会再次重置argv，argc，标准输入和标准输出。

###### 3.4.3 echo指令

echo指令相比于个人模块也做了较大调整。当时认为echo指令实现只需原样输出输入的内容，但事实上发现并不是这样。

echo也需要调用argv和argc，也需要与标准输入、标准输出关联，与解释器框架是正逆向的关系。因此这部分参考写好的解释器框架的代码进行了重写。

#### 3.5 扩展功能

除完整实现说明文档中的基本功能要求外，并未实现较大的扩展功能。

为方便测试并还原真实使用命令行的指令，增加了cls清屏指令与exit退出指令。~~只能说扩展了但没有完全扩展~~

### 4 后记与致谢

“Q：随机分组程序设计大作业是一种什么样的体验？”——多人团队合作开发真的比我们想象中要困难得多。

在“随机组队”的情况下，我们前期开发单人部分各有各的想法。因此，不仅程序调试过程中出现的问题是“相互耦合”的，而且整个团队也需要比较长的磨合时间才能走上正轨。除此之外，各种各样从来没有想到的问题也纷然而至，例如git多人开发不熟练导致整个项目回档、考试周临近debug进度不一样很难配合等……

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109222029553.png" alt="image-20220109222029553" style="zoom: 50%;" />

<center>多人git版本没对好发生回档惨案后的珍贵聊天记录</center>

但也正因如此，多人开发大作业的经历不仅是非常宝贵的开发经验，也是与组员一道十分难忘的回忆。在项目结束的最后回首，也很感谢程序设计基础这门课给予我们这样的一个机会。

在此我们衷心感谢王老师以及助教们的教学与指导，当然也要感谢全体组员的通力合作与辛勤付出。

**我们是最棒的！**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109221409962.png" alt="image-20220109221409962" style="zoom:35%;" />

